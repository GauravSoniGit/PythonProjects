"""
This parser script has api to convert text log files to excel scores and generate the comparison reports for the same
"""

import re
import os
import time
import sys
import logging
import xlsxwriter
import openpyxl
from datetime import datetime
from openpyxl import Workbook, load_workbook, styles, formatting
from openpyxl.styles.numbers import FORMAT_PERCENTAGE
from openpyxl.styles import NamedStyle, Font, PatternFill, Color

highlight = NamedStyle(number_format=FORMAT_PERCENTAGE, name="percent_style")
timestamp = datetime.strftime(datetime.now(), '%Y-%m-%d__%H_%M_%S')


def parser_script(log_path):
    """
    This api will create the excel file scores for the logs generated by benchmark tests
    :param:log_path: benchmark Logs location
    """
    try:
        log_path_list = [log_path]
        for folder in log_path_list:
            for root, dirs, files in os.walk(folder):
                for filename in files:
                    if filename.endswith(".txt"):
                        txt_path = os.path.abspath(os.path.join(root, filename))
                        if filename.startswith("rocthrust"):
                            Mathlibs_Parser.rocthrust_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("rocsparse"):
                            Mathlibs_Parser.rocsparse_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("hipsolver") or filename.startswith("rocsolver"):
                            Mathlibs_Parser.hipsolver_rocsolver_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("benchmark_rocrand_kernel") or filename.startswith(
                                "benchmark_rocrand_generate"):
                            Mathlibs_Parser.rocrand_generate_kernel_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("benchmark_rocrand_host_api"):
                            Mathlibs_Parser.rocrand_host_api_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("rocfft-rider"):
                            Mathlibs_Parser.rocfft_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("rocalution-bench"):
                            Mathlibs_Parser.rocalution_log_parser(log_path_list, txt_path, filename)
                        elif filename.startswith("hipblas") or filename.startswith("rocblas"):
                            Mathlibs_Parser.hipblas_rocblas_log_parser(log_path_list, txt_path, filename)

                        elif filename.startswith("hipPerfBufferCopySpeed") or filename.startswith(
                                "hipPerfBufferCopyRectSpeed"):
                            HipPerf_Parser.hipperf_buffercopyrectspeed_buffercopyspeed(log_path_list, txt_path,
                                                                                       filename)
                        elif filename.startswith("hipPerfDeviceConcurrency"):
                            HipPerf_Parser.hipperf_device_concurrency(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfDevMemReadSpeed") or filename.startswith(
                                "hipPerfDevMemWriteSpeed"):
                            HipPerf_Parser.hipperf_devmem_read_write_speed(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfDispatchSpeed"):
                            HipPerf_Parser.hipperf_dispatchspeed(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfDotProduct"):
                            HipPerf_Parser.hipperf_dotproduct(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfMandelbrot"):
                            HipPerf_Parser.hipperf_mandelbrot(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfMemcpy"):
                            HipPerf_Parser.hipperf_memcpy(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfMemMallocCpyFree"):
                            HipPerf_Parser.hipperf_memmalloccpyfree(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfSampleRate"):
                            HipPerf_Parser.hipperf_samplerate(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfSharedMemReadSpeed"):
                            HipPerf_Parser.hipperf_sharedmemreadspeed(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfStreamConcurrency"):
                            HipPerf_Parser.hipperf_streamconcurrency(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfStreamCreateCopyDestroy"):
                            HipPerf_Parser.hipperf_streamcreatecopydestroy(log_path_list, txt_path, filename)
                        elif filename.startswith("hipPerfMemset"):
                            HipPerf_Parser.hipperf_memset(log_path_list, txt_path, filename)

                        elif filename.startswith("hiprt"):
                            HipRT_Parser.hiprt_log_parser(log_path_list, txt_path, filename)

                        elif filename.startswith("hc") or filename.startswith("rp"):
                            HipCub_RocPrim_Parser.hipcub_rocprim_log_parser(log_path_list, txt_path, filename)

    except Exception as e:
        logging.error("Failed to run the parser script")
        logging.exception(e)


class Mathlibs_Parser:
    """
    Class contains api for all mathlibs benchmark logs to convert to excel scores
    """

    @staticmethod
    def rocalution_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for Rocalution benchmark
        :param filename: text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            sheet1 = book.add_worksheet()
            file_data_one_list = []
            with open(txt_path, "r") as f_in:
                text = re.split("Number of CPU cores", f_in.read())

            for ele in text:
                if ele.strip():
                    file_data_one_list.append(ele.strip())

            column_headings = ["sno"]

            row = 1
            for i in range(len(file_data_one_list)):
                sheet1.write(i + 1, 0, i + 1)
                column_heading_values = []
                file_each_line_list = file_data_one_list[i].split("\n")

                for j in range(len(file_each_line_list)):

                    krylov_basis = re.findall('krylov_basis\s+(\d+)', file_each_line_list[j])
                    if len(krylov_basis):
                        column_heading_values.append(krylov_basis[0])
                    if "krylov_basis" not in column_headings:
                        column_headings.append("krylov_basis")

                    preconditionar = re.findall('preconditioner\s+(\w+)', file_each_line_list[j])
                    if len(preconditionar) >= 1:
                        column_heading_values.append(preconditionar[0])
                    if "preconditioner" not in column_headings:
                        column_headings.append("preconditioner")

                    matrix = re.findall('matrix\s+(\w+)', file_each_line_list[j])
                    if len(matrix):
                        column_heading_values.append(matrix[0])
                    if "matrix" not in column_headings:
                        column_headings.append("matrix")

                    iterative_solver = re.findall('iterative_solver\s+(\w+)', file_each_line_list[j])
                    if len(iterative_solver):
                        column_heading_values.append(iterative_solver[0])
                    if "iterative_solver" not in column_headings:
                        column_headings.append("iterative_solver")

                    if file_each_line_list[j].startswith("convergence"):
                        last_line_column_headings = file_each_line_list[j].split(" ")

                        for ele in last_line_column_headings:
                            if ele.strip():
                                if ele.strip() not in column_headings:
                                    column_headings.append(ele.strip())
                        last_line_column_heading_values = file_each_line_list[j + 1].split(" ")

                        for ele in last_line_column_heading_values:
                            if ele.strip():
                                column_heading_values.append(ele.strip())

                for k in range(len(column_heading_values)):
                    sheet1.write(row, k + 1, column_heading_values[k])
                row += 1
            for i in range(len(column_headings)):
                sheet1.write(0, i, column_headings[i])
            book.close()

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for Rocalution")

    @staticmethod
    def rocthrust_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for Rocthrust benchmark
        :param filename:text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            # book = xlsxwriter.Workbook(f"{log_path_list[0]}/rocthrust.xlsx")
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            sheet1 = book.add_worksheet()
            sheet1.write(0, 0, "S No.")

            with open(txt_path, "r") as f_in:
                txt_file_data = f_in.read()
                labels = re.findall("(Thrust\sVersion.*)\n", txt_file_data)
                degrees = re.findall("(,,,bits/element.*)\n", txt_file_data)
                degrees_list = degrees[0].split(",")

                label_names = labels[0].split(",")

                res_lt = [label_names[x] + "(" + degrees_list[x] + ")" for x in range(len(label_names))]

                row = 0
                for name in range(len(res_lt)):
                    if "()" in res_lt[name]:
                        result = res_lt[name].replace("()", ' ')
                        sheet1.write(row, name + 1, result)
                    else:
                        sheet1.write(row, name + 1, res_lt[name])

                text = re.split("\n", txt_file_data)
                file_lines_list = text[3:-1]

                row = 1
                serial_number = 1
                for value in range(len(file_lines_list)):
                    lines_values_list = file_lines_list[value].split(",")
                    sheet1.write(serial_number, 0, serial_number)
                    for ele in range(len(lines_values_list)):
                        sheet1.write(row, ele + 1, lines_values_list[ele])
                        if ele == len(lines_values_list) - 1:
                            row += 1
                    serial_number += 1

            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for Rocthrust")

    @staticmethod
    def rocsparse_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for Rocsparse benchmark
        :param filename:text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                text = f_in.read().split("Opening")[1:]

            current_log_stripped_column_names = []
            row = 1
            # i = 1
            fixed_columns_heading = ["function", "trans", "opA", "opB", "M", "N", "K", "nnz_A", "nnz_B", "nnz", "nnz_C",
                                     "nnz_D", "bdim", "bdir", "alpha",
                                     "beta", "Algorithm", "GFlop/s", "GB/s"]
            sheet1.write(0, 0, "S.NO")
            sheet1.write(0, 1, "Test_Name")
            sheet1.write(0, 2, "Matrices")
            current_log_required_stripped_column_names = []
            length_value = []
            for ele in range(len(text)):
                sheet1.write(ele + 1, 0, ele + 1)
                sheet1.write(ele + 1, 1, "rocsparse")
                all_stripped_values = []
                indexes_current_log_stripped_column_names = []
                if " file " in text[ele]:
                    matrices_line = re.findall(".*file\s+'(.*).csr.*", text[ele])
                    try:
                        name = matrices_line[0].split("/")[-1]
                        # name = matrices_line[0]
                        sheet1.write(row, 2, name)
                        # flag+=1
                    except Exception as e:
                        matrices = re.findall(".*file\s+'(.*).csr.*", text[ele])
                        sheet1.write(row, 2, matrices[0])
                        # flag+=1

                if "trans" in text[ele] or "M        " in text[ele] or "opA              opB" in text[ele]:
                    data = text[ele].split("\n")
                    for line in range(len(data)):
                        if data[line].startswith("M        ") or data[line].startswith("trans") or data[
                            line].startswith(
                            "opA              opB"):
                            label_names = data[line].split(" ")

                            for ele in label_names:
                                if ele.strip():
                                    if ele.strip() not in current_log_stripped_column_names:
                                        current_log_stripped_column_names.append(ele.strip())
                            length_value.append(len(current_log_stripped_column_names))
                            all_values = data[line + 1].split(" ")
                            for name in fixed_columns_heading:
                                if name in current_log_stripped_column_names:
                                    if name not in current_log_required_stripped_column_names:
                                        current_log_required_stripped_column_names.append(name)

                            for name in current_log_required_stripped_column_names:
                                named_data = current_log_stripped_column_names.index(name)
                                indexes_current_log_stripped_column_names.append(named_data)

                            for ele in all_values:
                                if ele.strip():
                                    all_stripped_values.append(ele.strip())
                            required_all_strip_values = []
                            for value in range(len(indexes_current_log_stripped_column_names)):
                                sheet1.write(row, value + 3,
                                             all_stripped_values[indexes_current_log_stripped_column_names[value]])

                                required_all_strip_values.append(
                                    all_stripped_values[indexes_current_log_stripped_column_names[value]])

                                if value == len(indexes_current_log_stripped_column_names) - 1:
                                    row += 1
                else:
                    for i in range(len(current_log_required_stripped_column_names)):
                        sheet1.write(row, i + 3, "notrun")
                        if i == len(current_log_required_stripped_column_names) - 1:
                            row += 1
            for f in range(len(current_log_required_stripped_column_names)):
                sheet1.write(0, f + 3, current_log_required_stripped_column_names[f])
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for Rocsparse")

    @staticmethod
    def rocrand_generate_kernel_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for Rocrand generate and kernel benchmark
        :param filename:text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            # test_name = filename.replace(".txt", "")
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                text = f_in.read().split("\n\n")  # text = file_data_divided_list with redundant info
            file_data_divided_list = text[1:]

            names = text[0]
            test = names.split("\n")
            benchmark_test_name = test[0].replace(".exe", "")

            row_number = 1

            sheet1.write(0, 0, "sno ")
            sheet1.write(0, 1, f"Testname")
            sheet1.write(0, 2, f"Module")
            sheet1.write(0, 3, f"Subtests ")
            sheet1.write(0, 4, f"AvgTime (ms)")
            sheet1.write(0, 5, f"Time (ms)")
            sheet1.write(0, 6, f"Size")
            sheet1.write(0, 7, f"Samples (GSample/s)")
            sheet1.write(0, 8, f"Throughput (GB/S)")

            for ele in range(len(file_data_divided_list)):
                file_data_divided_each_line_list = file_data_divided_list[ele].split("\n")

                outer_test_name = [file_data_divided_each_line_list[0]]

                scores_values_list = []
                inner_each_line_list = [i for i in file_data_divided_each_line_list if
                                        i.strip().startswith('Throughput')]

                for value in inner_each_line_list:
                    x = re.findall('=\s+([0-9\.\s+]+)', value)
                    scores_values_list.append(x)

                inner_test_all_lines_list = [line for line in file_data_divided_each_line_list if
                                             line not in outer_test_name]

                inner_test_names_list = [line for line in inner_test_all_lines_list if line not in inner_each_line_list]

                x = 0
                try:
                    index = inner_test_names_list.index('  poisson:')
                    inner_test_names_list[index] = "  poisson lambda 10.0:"
                    inner_test_names_list.remove("    lambda 10.0")
                    index = inner_test_names_list.index('  discrete-poisson:')
                    inner_test_names_list[index] = "discrete-poisson lambda 10.0:"
                    inner_test_names_list.remove("    lambda 10.0")
                except Exception:
                    abc_pass = 0
                for j in range(len(inner_test_names_list)):
                    sheet1.write(row_number + j, 1, benchmark_test_name)
                    sheet1.write(row_number + j, 0, row_number + j)  # serial number
                    sheet1.write(row_number + j, 2, outer_test_name[0])
                    sheet1.write(row_number + j, 3, inner_test_names_list[j])

                scores_values_list_swapped_values_list = []
                for lst in scores_values_list:
                    lst.append(lst.pop(lst.index(lst[1])))
                    lst.append(lst.pop(lst.index(lst[0])))
                    scores_values_list_swapped_values_list.append(lst)

                for i in range(len(scores_values_list_swapped_values_list)):
                    for l in range(len(scores_values_list_swapped_values_list[i])):
                        if l == 0:  # No use of this if statement in the latest logs
                            if "T" in scores_values_list_swapped_values_list[i][l]:
                                # This if is not used in latest
                                value = scores_values_list_swapped_values_list[i][l].replace("T", "")
                                result = float(value) * 1024
                                sheet1.write(row_number + x, l + 4, result)
                            else:
                                G_value = scores_values_list_swapped_values_list[i][l].replace("GB", "")
                                sheet1.write(row_number + x, l + 4, G_value)
                        else:
                            if "GSample" in scores_values_list_swapped_values_list[i][l] or "ms" in \
                                    scores_values_list_swapped_values_list[i][l]:
                                # This if is not used in the latest logs
                                output = re.split("([0-9\.]+)\s+\w+", scores_values_list_swapped_values_list[i][l])
                                sheet1.write(row_number + x, l + 4, output[1])
                            else:
                                sheet1.write(row_number + x, l + 4, scores_values_list_swapped_values_list[i][l])
                    x += 1
                row_number += len(inner_test_names_list)
            book.close()

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for Rocrand Generate and Kernel")

    @staticmethod
    def rocrand_host_api_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for Rocrand host api benchmark
        :param filename:text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            # test_name = filename.replace(".txt", "")
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            degree = []
            # if dir.endswith('.txt'):
            #     fo = open(dir, 'r', encoding='utf-8')
            #
            sheet1 = book.add_worksheet()

            line_cnt = 0
            row_cnt = 1
            with open(txt_path, "r") as full_file:
                full_file = full_file.read()
                file_lines_list = re.split("\n", full_file)

                for line in file_lines_list:
                    each_line_list_items = []
                    if line_cnt > 2:
                        match_obj = re.search(
                            r"(.*)\s+(\d+\.?\d+ ms)\s+(\d+\.?\d+ ms)\s+(\d+)\s+(bytes_.*)\s+(items_.*)$",
                            line)
                        if match_obj:
                            each_line_list_items = [
                                match_obj.group(1),
                                match_obj.group(2),
                                match_obj.group(3),
                                match_obj.group(4),
                                match_obj.group(5),
                                match_obj.group(6)
                            ]

                            time_list = re.split("\d+\s+(\w+)", each_line_list_items[1])
                            degree.append(time_list[1])

                            cpu = re.split("\d+\s+(\w+)", each_line_list_items[2])
                            degree.append(time_list[1])

                            user_counter_byte_per_sec_list = re.split("(\w+=)\d+", each_line_list_items[4])
                            user_counter_items_per_sec_list = re.split("(\w+=)\d+", each_line_list_items[5])

                            degree.append(user_counter_byte_per_sec_list[1])
                            degree.append(user_counter_byte_per_sec_list[1])

                            time_value = each_line_list_items[1].replace(time_list[1], "")
                            cpu_value = each_line_list_items[2].replace(cpu[1], "")
                            user_counter_byte_per_sec_value = each_line_list_items[4].replace(
                                user_counter_byte_per_sec_list[1],
                                " ")
                            user_counter_items_per_sec_value = each_line_list_items[5].replace(
                                user_counter_items_per_sec_list[1], " ")

                            convert = re.split("\d+(\w+/\w+)", user_counter_byte_per_sec_value)
                            convert_items = re.split("\d+(\w+/\w+)", user_counter_items_per_sec_value)

                            content_len = 0

                            while content_len < len(each_line_list_items):
                                if content_len == 1:
                                    sheet1.write(row_cnt, content_len, time_value)
                                elif content_len == 2:
                                    sheet1.write(row_cnt, content_len, cpu_value)
                                elif content_len == 4:
                                    if convert[1] == "T/s":
                                        x = user_counter_byte_per_sec_value.replace("T/s", "")
                                        result = float(x) * 1024
                                        sheet1.write(row_cnt, content_len, result)
                                    elif convert[1] == "P/s":
                                        y = user_counter_byte_per_sec_value.replace("P/s", "")
                                        result_y = float(y) * 1048576
                                        sheet1.write(row_cnt, content_len, result_y)
                                    elif convert[1] == "G/s":
                                        value = user_counter_byte_per_sec_value.replace("G/s", "")
                                        sheet1.write(row_cnt, content_len, value)
                                elif content_len == 5:
                                    if convert_items[1] == "T/s":
                                        l = user_counter_items_per_sec_value.replace("T/s", "")
                                        result_l = float(l) * 1024
                                        sheet1.write(row_cnt, content_len, result_l)
                                    elif convert_items[1] == "P/s":
                                        m = user_counter_items_per_sec_value.replace("P/s", "")
                                        result_m = float(m) * 1048576
                                        sheet1.write(row_cnt, content_len, result_m)
                                    elif convert_items[1] == "G/s":
                                        value = user_counter_items_per_sec_value.replace("G/s", "")
                                        sheet1.write(row_cnt, content_len, value)
                                else:
                                    sheet1.write(row_cnt, content_len, each_line_list_items[content_len])
                                    # This will write iterations
                                content_len += 1
                            row_cnt += 1
                    line_cnt += 1
                sheet1.write(0, 0, "Benchmark ")
                sheet1.write(0, 1, f"Time (ms)")
                sheet1.write(0, 2, f"CPU (ms)")
                sheet1.write(0, 3, f"Iterations ")
                sheet1.write(0, 4, f"UserCounters_bytes_persec(Gb/S)")
                sheet1.write(0, 5, f"UserCounters_items_persec(gB/S)")
            book.close()

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for Rocrand host api ")

    @staticmethod
    def rocfft_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for Rocfft benchmark
        :param filename:text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            sheet1 = book.add_worksheet()
            full_file_tests_list = []
            with open(txt_path, "r") as f_in:
                full_file_tests_list_unstripped = re.split("rocfft-rider", f_in.read())
            for ele in full_file_tests_list_unstripped:
                if ele.strip():
                    full_file_tests_list.append(ele.strip())

            sno = 1
            row_number = 1
            row_number_batch_value = 1
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "Name")
            sheet1.write(0, 2, "Testname")
            sheet1.write(0, 4, "Average")
            sheet1.write(0, 3, "Batch")
            test_command = []

            for j in range(len(full_file_tests_list)):
                test_command.append(full_file_tests_list[j].split("\n")[0])
                profile_values = re.findall('Running profile with(\s+[0-9.\s]+)', full_file_tests_list[j])
                length_value = re.findall('length.*:(\s+[0-9.\s]+)', full_file_tests_list[j])
                gpu_time_gflop_name_title_list = re.findall('Execution (.*):', full_file_tests_list[j])

                run_values_list = []
                # run_values_list is created to append "na" if test failed to run
                try:
                    values = re.findall('Execution.*:(\s+[0-9.\s]+)', full_file_tests_list[j])
                    run_values_list.append(values[0])
                    run_values_list.append(values[1])

                except Exception:
                    run_values_list.append(" na")
                    run_values_list.append(" na")

                batch_value = re.findall('.*\w*_batch_(\d*)_', full_file_tests_list[j])

                for i in run_values_list:
                    sheet1.write(row_number, 0, row_number)
                    sheet1.write(row_number, 1, "rocfft")

                    each_value_list_unstripped = re.split("\s", i)
                    each_value_list = []
                    for ele in each_value_list_unstripped:
                        if ele.strip():
                            each_value_list.append(ele.strip())

                    length = len(each_value_list)
                    if length > 1:
                        sum = 0
                        for z in range(len(each_value_list)):
                            sum += float(each_value_list[z])

                        sheet1.write(row_number, 4, sum / length)
                        row_number += 1
                    else:
                        sheet1.write(row_number, 4, each_value_list[0])
                        row_number += 1
                        sno += 1
                for i in range(len(run_values_list)):
                    sheet1.write(row_number_batch_value, 2, f"rider_length-{test_command[0]}")
                    if len(batch_value):
                        sheet1.write(row_number_batch_value, 3, batch_value[0])
                        row_number_batch_value += 1
            book.close()

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for Rocfft-rider ")

    @staticmethod
    def hipblas_rocblas_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for HipBlas and RocBlas benchmarks
        :param filename:text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            sheet1 = book.add_worksheet()
            test_name = filename.split("blas")
            file_each_run_list = []
            with open(txt_path, "r") as f_in:
                text = re.split(".*blas-bench", f_in.read())
            for ele in text:
                if ele.strip():
                    file_each_run_list.append(ele.strip())
            sheet1.write(0, 0, "sno ")
            sheet1.write(0, 1, f"Testname")
            sheet1.write(0, 2, f"Subtests ")
            sheet1.write(0, 3, f"mode ")
            required_column_headings = []
            list_of_required_columns_values_list = []
            subtest_names = []
            length = []
            for i in range(len(file_each_run_list)):
                if "transA,transB" in file_each_run_list[i] or "N,incx,incy" in file_each_run_list[i] or "transA,M" in \
                        file_each_run_list[i] or "M,N,alpha" in file_each_run_list[
                    i] or "transA_option,transB_option" in \
                        file_each_run_list[i]:
                    each_run_each_line_list = file_each_run_list[i].split("\n")

                    subtest = each_run_each_line_list[0]
                    subtest_names.append(subtest)
                    for j in range(len(each_run_each_line_list)):

                        if each_run_each_line_list[j].startswith("trans") or each_run_each_line_list[j].startswith(
                                "N,incx,incy") or each_run_each_line_list[j].startswith("transA,M") or \
                                each_run_each_line_list[j].startswith("M,N,alpha"):
                            required_column_headings_unstripped = each_run_each_line_list[j].split(",")

                            for k in range(len(required_column_headings_unstripped)):
                                if required_column_headings_unstripped[k] not in required_column_headings:
                                    if required_column_headings_unstripped[k].strip():
                                        required_column_headings.append(required_column_headings_unstripped[k])
                            length.append(len(required_column_headings))

                            values_list = []
                            try:
                                values = each_run_each_line_list[j + 1].split(",")
                                required_columns_values_list = []
                                for value in values:
                                    if value.strip():
                                        required_columns_values_list.append(value)

                                temp = required_columns_values_list[-1]
                                required_columns_values_list[-1] = required_columns_values_list[-2]
                                required_columns_values_list[-2] = temp
                                list_of_required_columns_values_list.append(required_columns_values_list)

                            except Exception as e:
                                for i in range(len(required_column_headings)):
                                    values_list.append("na")
                                list_of_required_columns_values_list.append(values_list)

                else:
                    temp_not_run_list = []
                    each_run_each_line_list = file_each_run_list[i].split("\n")
                    subtest = each_run_each_line_list[0]
                    subtest_names.append(subtest)
                    for i in range(length[0]):
                        temp_not_run_list.append("Not Run")
                    list_of_required_columns_values_list.append(temp_not_run_list)

            temp = required_column_headings[-1]
            required_column_headings[-1] = required_column_headings[-2]
            required_column_headings[-2] = temp

            for l in range(len(required_column_headings)):
                sheet1.write(0, l + 4, required_column_headings[l])

            row_number = 1
            for i in range(len(subtest_names)):
                sheet1.write(i + 1, 2, subtest_names[i])
                sheet1.write(i + 1, 0, i + 1)
                sheet1.write(i + 1, 1, f"{test_name[0]}blas_customertests")
                sheet1.write(i + 1, 3, "customer")
            for value in list_of_required_columns_values_list:
                for ele in range(len(value)):
                    sheet1.write(row_number, ele + 4, value[ele])
                    if ele == len(value) - 1:
                        row_number += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipblas_rocblas")

    @staticmethod
    def hipsolver_rocsolver_log_parser(log_path_list, txt_path, filename):
        """
        This api will generate excel file for HipSolver and RocSolver benchmarks
        :param filename: text filename
        :param log_path_list: Path of text files
        :param txt_path: txt file full location
        """
        try:
            test_name = filename.replace(".txt", "")
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            sheet1 = book.add_worksheet()
            file_text_split_strip = []

            with open(txt_path, "r") as f_in:
                file_text_split = re.split(".*-bench", f_in.read())

            for ele in file_text_split:
                if ele.strip():
                    file_text_split_strip.append(ele.strip())

            row = 1
            serial_number_row = 1
            flag2 = 1
            name_check = ".exe"
            columns_headings = ["S no", "Test", "Subtest"]
            column_result_values = []

            for x in range(len(file_text_split_strip)):
                column_values = []
                file_text_lines_list = re.split("\n", file_text_split_strip[x])  # To create list of list

                for i in range(len(file_text_lines_list)):
                    if name_check in file_text_lines_list[i]:
                        subtest = re.findall(".*-f\s+(\w+)\s+.*", file_text_lines_list[i])[0] + "-" + \
                                  re.findall(".*-r\s+(\w+)\s+.*", file_text_lines_list[i])[0]
                        command = re.findall(".exe(.*)", file_text_lines_list[i])[0].replace(' ', '-')

                        if command[-1] == "-":
                            command = command[1:-1]

                        sheet1.write(serial_number_row, 0, serial_number_row)
                        sheet1.write(serial_number_row, 1, f"{test_name}" + command)
                        sheet1.write(serial_number_row, 2, subtest)
                        serial_number_row += 1

                    if file_text_lines_list[i].startswith("Arguments:"):
                        column_names_unstrip = file_text_lines_list[i + 2].split(" ")

                        for ele in column_names_unstrip:
                            if ele.strip():  # if ele.strip means if element not empty in list
                                if ele.strip() not in columns_headings:
                                    columns_headings.append(ele.strip())

                        values = file_text_lines_list[i + 3].split(" ")

                        for ele in values:
                            if ele.strip():
                                column_values.append(ele.strip())

                    if file_text_lines_list[i].startswith("Results:"):
                        times = file_text_lines_list[i + 2].split(" ")
                        for ele in times:
                            if ele.strip():
                                if ele.strip() not in columns_headings:
                                    columns_headings.append(ele.strip())
                        time_values = file_text_lines_list[i + 3].split(" ")
                        column_result_values = column_values
                        for ele in time_values:
                            if ele.strip():
                                column_result_values.append(ele.strip())

                for i in range(len(column_result_values)):
                    sheet1.write(row, i + 3, column_result_values[i])
                row += 1
            for name in range(len(columns_headings)):
                sheet1.write(0, name, columns_headings[name])
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipsolver_rocsolver")


class HipPerf_Parser:
    @staticmethod
    def hipperf_buffercopyrectspeed_buffercopyspeed(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf buffercoptrectspeed and buffercopyspeed benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            sheet1 = book.add_worksheet()

            row = 1
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "Tc_name")
            sheet1.write(0, 2, "memory")
            sheet1.write(0, 3, "timeformat")
            sheet1.write(0, 4, "i: (GB/s)")
            sheet1.write(0, 5, "perf (GB/S)")
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n")
            for i in range(len(full_file_each_line_list)):
                if full_file_each_line_list[i].startswith("HIPPerf"):
                    line_each_word_list = full_file_each_line_list[i].split("	")
                    name = line_each_word_list[0]
                    memory_value = re.findall("\(\s*(\d+\s)bytes\)", line_each_word_list[1])
                    time_format = line_each_word_list[2]
                    i_value = re.findall("i:\s*(.*)", line_each_word_list[3])
                    perf_value = line_each_word_list[5]
                    sheet1.write(row, 0, row)
                    sheet1.write(row, 1, name)
                    sheet1.write(row, 2, memory_value[0])
                    sheet1.write(row, 3, time_format)
                    sheet1.write(row, 4, i_value[0])
                    sheet1.write(row, 5, perf_value)
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipperf buffercoptrectspeed and buffercopyspeed")

    @staticmethod
    def hipperf_device_concurrency(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipper device concurrency benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()

            row = 1
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "kernel")
            sheet1.write(0, 2, "Streams")
            sheet1.write(0, 3, "Measured time (s)")
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n")
            for line in range(len(full_file_each_line_list)):
                if full_file_each_line_list[line].startswith("Measured"):
                    test_name = full_file_each_line_list[line].split(":")[0]
                    kernal = []
                    try:
                        kernal_value = re.findall(".*(\d+)\s+kernel.*", test_name)
                        kernal.append(kernal_value[0])
                    except Exception as e:
                        kernal.append(1)
                    streams = []
                    try:
                        streams_value = re.findall(".*(\d+)\s+device.*", test_name)
                        streams.append(streams_value[0])
                    except Exception as e:
                        streams.append(1)
                    values = full_file_each_line_list[line].split(":")[1].replace("(s)", " ")
                    sheet1.write(row, 0, row)
                    sheet1.write(row, 1, kernal[0])
                    sheet1.write(row, 2, streams[0])
                    sheet1.write(row, 3, values)
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipperf device concurrency")

    @staticmethod
    def hipperf_devmem_read_write_speed(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf_devmem_read_write_speed benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("info:")
            sheet1.write(0, 0, "Sno")
            if filename.startswith("hipPerfDevMemReadSpeed"):
                sheet1.write(0, 2, "Average Read speed(GB/S)")
            if filename.startswith("hipPerfDevMemWriteSpeed"):
                sheet1.write(0, 2, "Average Write speed(GB/S)")
            sheet1.write(0, 1, "Memory size (MB)")
            row = 1
            for i in range(len(full_file_each_line_list)):
                if "memory size" in full_file_each_line_list[i]:
                    sheet1.write(row, 0, row)
                    memory_size = re.findall(".*memory size of\s+(\d.*)", full_file_each_line_list[i])
                    speed_value = re.findall(".*speed of\s+(\d+.?\d+\s+\w+/\w+).*", full_file_each_line_list[i])
                    if "TB/s" in speed_value[0]:
                        x = speed_value[0].replace("TB/s", " ")
                        speed_value_gb = float(x) * 1024
                        sheet1.write(row, 2, speed_value_gb)
                    else:
                        y = speed_value[0].replace("GB/s", " ")
                        sheet1.write(row, 2, y)

                    if "GB" in memory_size[0]:
                        x = memory_size[0].replace("GB", " ")
                        memory_size_mb = float(x) * 1024
                        sheet1.write(row, 1, memory_size_mb)
                    else:
                        y = memory_size[0].replace("MB", " ")
                        sheet1.write(row, 1, y)
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfDevMemReadSpeed / hipPerfDevMemWriteSpeed")

    @staticmethod
    def hipperf_dispatchspeed(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf dispatchSpeed benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            sheet1.write(0, 0, "SNO")
            sheet1.write(0, 1, "TC_NAME")
            sheet1.write(0, 2, "Dispatch_value")
            sheet1.write(0, 3, "SPIN")
            sheet1.write(0, 4, "time_value (us/disp)")
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n")[1:-2]

            for i in range(len(full_file_each_line_list)):
                sheet1.write(i + 1, 0, i + 1)
                test_name = re.findall("(HIPPer.*])", full_file_each_line_list[i])
                dispatch_value = re.findall(".*\s+(\d+)\s+dispatches.*", full_file_each_line_list[i])
                spin = re.findall(".*dispatches\s+(.*).*\(us/disp\).*", full_file_each_line_list[i])
                time_value = re.findall(".*\(us/disp\)\s+(\d+.?\d+).*", full_file_each_line_list[i])
                if len(test_name) or len(dispatch_value) or len(spin) or len(time_value):
                    sheet1.write(i + 1, 1, test_name[0])
                    sheet1.write(i + 1, 2, dispatch_value[0])
                    sheet1.write(i + 1, 3, spin[0])
                    sheet1.write(i + 1, 4, time_value[0])
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfDispatchSpeed")

    @staticmethod
    def hipperf_dotproduct(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf dispatchSpeed benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            sheet1.write(0, 0, "SNO")
            sheet1.write(0, 1, "vector size")
            sheet1.write(0, 2, "Time(msec)")
            sheet1.write(0, 4, "size(GB/s)")
            sheet1.write(0, 3, "flop_size(Gflops/s)")
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n\n")[1:]

            row = 1
            for i in range(len(full_file_each_line_list)):
                sheet1.write(row, 0, i + 1)
                vector_size = re.findall(".*Vector Size:\s+(.*).*", full_file_each_line_list[i])
                sheet1.write(row, 1, vector_size[0])
                dot_size = re.findall(".*\[ddot\] <x,y>\s+(\d+.?\d+)msec", full_file_each_line_list[i])
                bytes_throughput = re.findall(".*;(\d+).*;.*", full_file_each_line_list[i])
                flops_throughput = re.findall(".*;(\d+).*", full_file_each_line_list[i])
                for j in range(len(dot_size)):
                    sheet1.write(row, 2, dot_size[j])
                    sheet1.write(row, 3, flops_throughput[j])
                    sheet1.write(row, 4, bytes_throughput[j])
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfDotProduct")

    @staticmethod
    def hipperf_mandelbrot(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf MandelBrot benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                full_file_each_test_list = f_in.read().split("Measured")[1:]
            row = 1
            sheet1.write(0, 0, "s.no")
            sheet1.write(0, 1, "streams")
            sheet1.write(0, 2, "type")
            sheet1.write(0, 3, "value i")
            sheet1.write(0, 4, "value ii")
            sheet1.write(0, 5, "value(s)")
            for i in range(len(full_file_each_test_list)):
                result_list = []
                each_test_each_line_list = full_file_each_test_list[i].split("\n")
                stream_name = re.findall(".*kernels in GFLOPS\s+(.*)", full_file_each_test_list[i])
                sheet1.write(row, 0, i + 1)
                sheet1.write(row, 1, stream_name[0])
                for j in range(len(each_test_each_line_list[2:-2])):
                    each_test_each_line_each_word_list = each_test_each_line_list[2:-2][j].split(" ")
                    for ele in each_test_each_line_each_word_list:
                        if ele.strip():
                            result_list.append(ele.strip())
                i = 0
                for k in range(len(result_list)):
                    sheet1.write(row, i + 2, result_list[k])
                    i += 1
                    if i % 4 == 0:
                        row += 1
                        i = 0
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfMandelbrot")

    @staticmethod
    def hipperf_memcpy(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf memcpy benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n")
            sheet1.write(0, 0, "Sno")
            sheet1.write(0, 1, "TC name")
            sheet1.write(0, 2, "Bytes")
            sheet1.write(0, 3, "Time (us)")
            row = 1
            for i in range(len(full_file_each_line_list)):
                if full_file_each_line_list[i].startswith("hipPerf"):
                    tc_name = re.findall("(hip.*)Host.*", full_file_each_line_list[i])
                    memory_size = re.findall(".*memory size of\s+(\d.*)", full_file_each_line_list[i])
                    Device_copy_time = re.findall(".*Device copy took\s+(\d+.?\d+).*", full_file_each_line_list[i])
                    sheet1.write(row, 0, row)
                    if len(tc_name):
                        sheet1.write(row, 1, tc_name[0])
                    if len(memory_size):
                        sheet1.write(row, 2, memory_size[0])
                    if len(Device_copy_time):
                        sheet1.write(row, 3, Device_copy_time[0])
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfMemCpy")

    @staticmethod
    def hipperf_memmalloccpyfree(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipPerfMemMallocCpyFree benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n")
            sheet1.write(0, 0, "Sno")
            sheet1.write(0, 1, "type")
            sheet1.write(0, 2, "Test Name")
            sheet1.write(0, 3, "cost")
            sheet1.write(0, 4, "Time (us)")
            all_tests_each_line_list = []
            for i in range(len(full_file_each_line_list[2:-2])):
                all_tests_each_line_list.append(full_file_each_line_list[2:-2][i])
            for j in range(len(all_tests_each_line_list)):
                sheet1.write(j + 1, 0, j + 1)
                if j % 4 == 0:
                    sheet1.write(j + 1, 1, all_tests_each_line_list[j])
                else:
                    each_test_each_word_list = all_tests_each_line_list[j].split(" ")
                    sheet1.write(j + 1, 2, each_test_each_word_list[0])
                    if len(each_test_each_word_list):
                        sheet1.write(j + 1, 3, each_test_each_word_list[1])
                        sheet1.write(j + 1, 4, each_test_each_word_list[2].replace("us", " "))
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfMemMallocCpyFree")

    @staticmethod
    def hipperf_samplerate(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf samplerate benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                all_tests_each_line_list = f_in.read().split("\n")[1:-2]
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "Domain_name")
            sheet1.write(0, 2, "(GB/s)")
            for line in range(len(all_tests_each_line_list)):
                name = re.findall("(Domain.*\))", all_tests_each_line_list[line])
                value = re.findall("Domain.*\s+(\d+.?\d+)", all_tests_each_line_list[line])
                sheet1.write(line + 1, 0, line + 1)
                sheet1.write(line + 1, 1, name[0])
                sheet1.write(line + 1, 2, value[0])
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfSampleRate")

    @staticmethod
    def hipperf_sharedmemreadspeed(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf samplerate benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("info:")
            sheet1.write(0, 0, "Sno")
            sheet1.write(0, 1, "Memory size (MB)")
            sheet1.write(0, 2, "Threads")
            sheet1.write(0, 3, "Kernal_reads")
            sheet1.write(0, 4, "Average read speed(GB/S)")
            row = 1
            for i in range(len(full_file_each_line_list)):
                if "shared memory " in full_file_each_line_list[i]:
                    sheet1.write(row, 0, row)
                    memory_size = re.findall(".*for\s+(\d+\s+\w+).*", full_file_each_line_list[i])
                    read_speed = re.findall(".*read speed = \s+(\d+.?\d+\s+\w+/\w+).*", full_file_each_line_list[i])
                    threads = re.findall(".*shared memory with\s+(\d+\s+\w+).*", full_file_each_line_list[i])
                    reads = re.findall(".*,\s+(\d+)\s+reads in ", full_file_each_line_list[i])
                    if "TB/s" in read_speed[0]:
                        x = read_speed[0].replace("TB/s", " ")
                        read_speed_gb = float(x) * 1024
                        sheet1.write(row, 4, read_speed_gb)
                    else:
                        y = read_speed[0].replace("GB/s", " ")
                        sheet1.write(row, 4, y)

                    if "GB" in memory_size[0]:
                        x = memory_size[0].replace("GB", " ")
                        memory_size_mb = float(x) * 1024
                        sheet1.write(row, 1, memory_size_mb)
                    elif "KB" in memory_size[0]:
                        x = memory_size[0].replace("KB", " ")
                        memory_size_kb = float(x) / 1024
                        sheet1.write(row, 1, memory_size_kb)
                    else:
                        x = memory_size[0].replace("MB", " ")
                        sheet1.write(row, 2, x)
                    sheet1.write(row, 2, threads[0])
                    sheet1.write(row, 3, reads[0])
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfSharedMemReadSpeed")

    @staticmethod
    def hipperf_streamconcurrency(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf samplerate benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            row = 1
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "kernel")
            sheet1.write(0, 2, "Streams")
            sheet1.write(0, 3, "Measured time (s)")
            with open(txt_path, "r") as f_in:
                full_file_each_line_list = f_in.read().split("\n")
            for line in range(len(full_file_each_line_list)):
                if full_file_each_line_list[line].startswith("Measured"):
                    test_name = full_file_each_line_list[line].split(":")[0]
                    kernel = []
                    try:
                        kernel_value = re.findall(".*(\d+)\s+kernels.*", test_name)
                        kernel.append(kernel_value[0])
                    except Exception as e:
                        kernel.append(1)
                    streams = []
                    try:
                        streams_value = re.findall(".*(\d+)\s+stream.*", test_name)
                        streams.append(streams_value[0])
                    except Exception as e:
                        streams.append(1)
                    values = full_file_each_line_list[line].split(":")[1].replace("(s)", " ")
                    sheet1.write(row, 0, row)
                    sheet1.write(row, 1, kernel[0])
                    sheet1.write(row, 2, streams[0])
                    sheet1.write(row, 3, values)
                    row += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfStreamConcurrency")

    @staticmethod
    def hipperf_streamcreatecopydestroy(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf samplerate benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            row = 1
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "streams")
            sheet1.write(0, 2, "buffers")
            sheet1.write(0, 3, "iterations")
            sheet1.write(0, 4, "CCD time (ms)")
            with open(txt_path, "r") as f_in:
                each_test_each_line_list = f_in.read().split("\n")[2:-2]
            for line in range(len(each_test_each_line_list)):
                streams = re.findall(".*(\d+)\s+stream.*", each_test_each_line_list[line])
                buffers = re.findall(".*\s+(\d+)\s+buffers.*", each_test_each_line_list[line])
                iterations = re.findall(".*\s+(\d+)\s+iterations.*", each_test_each_line_list[line])
                value = re.findall(".*iterations\s+(.*)", each_test_each_line_list[line])[0].replace("(ms)", " ")
                sheet1.write(row, 0, row)
                sheet1.write(row, 1, streams[0])
                sheet1.write(row, 2, buffers[0])
                sheet1.write(row, 3, iterations[0])
                sheet1.write(row, 4, value)
                row += 1
            book.close()

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfStreamCreateCopyDestroy")

    @staticmethod
    def hipperf_memfill(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf samplerate benchmark
         :param filename: text filename
         :param log_path_list: current log files path
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()
            with open(txt_path, "r") as f_in:
                text = f_in.read().split("Test")[2:]

            name = []
            flag = 0
            for i in range(len(text)):
                data = text[i].split("\n")
                name.append("Test" + data[0])
                sheet1.write(flag + 1, 0, name[i])
                sheet1.write(0, 0, "Sno")
                sheet1.write(0, 1, "MEMORY/SIZE")
                sheet1.write(0, 2, "Bandwidth (GB/S)")
                sheet1.write(0, 3, "Costs (s)")

                for j in range(len(data[1:-1])):

                    host_fill = re.findall("\[(.*)GB\]", data[1:-1][j])
                    if host_fill:
                        sheet1.write(j + flag + 2, 0, j + 1)
                        sheet1.write(j + flag + 2, 1, host_fill[0])
                    cost_time_taken = re.findall(".*cost\s+(\d+.?\d+).*", data[1:-1][j])
                    if cost_time_taken:
                        sheet1.write(j + flag + 2, 3, cost_time_taken[0])
                    band_width = re.findall(".*bandwidth\s+(\d+.?\d+).*", data[1:-1][j])
                    if band_width:
                        sheet1.write(j + flag + 2, 2, band_width[0])
                    if j == 4:
                        flag += 7
            book.close()

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipperf_memfill")

    @staticmethod
    def hipperf_memset(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf memset benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()

            with open(txt_path, "r") as f_in:
                full_file_3_test_list = f_in.read().split("\n\n\n")
            one_d_each_line_list = full_file_3_test_list[0].split("\n")
            sheet1.write(0, 0, "SNO")
            sheet1.write(0, 1, "TC NAME")
            # sheet1.write(0, 2, "Subtest")
            sheet1.write(0, 2, "size")
            sheet1.write(0, 3, "Typesize-type")
            sheet1.write(0, 4, "Typesize (GB/S)")
            flag = 1
            list_1d_arrays = [" ", "Perf of hipMemsetAsync for 1D arrays"]
            list_2d_arrays = [" ", "Perf of hipMemsetAsync for 2D arrays"]
            list_3d_arrays = [" ", "Perf of hipMemsetAsync for 3D arrays"]
            k = 0
            l = 0
            for i in range(len(one_d_each_line_list[3:])):
                one_d_each_line_each_word_list_stripped = []
                one_d_each_line_required_word_list = []
                if one_d_each_line_list[3:][i].startswith("API:"):
                    one_d_each_line_each_word_list = one_d_each_line_list[3:][i].split(" ")

                    for ele in one_d_each_line_each_word_list:
                        if ele.strip():
                            one_d_each_line_each_word_list_stripped.append(ele.strip())
                    try:
                        one_d_each_line_required_word_list.append(one_d_each_line_each_word_list_stripped[0] +
                                                                  one_d_each_line_each_word_list_stripped[1] +
                                                                  "  " +
                                                                  one_d_each_line_each_word_list_stripped[2])

                        one_d_each_line_required_word_list.append((one_d_each_line_each_word_list_stripped[3] +
                                                                   one_d_each_line_each_word_list_stripped[4]))
                        type_size = re.findall("(\d+):", one_d_each_line_each_word_list_stripped[6])
                        one_d_each_line_required_word_list.append(
                            one_d_each_line_each_word_list_stripped[5] + type_size[0])
                        one_d_each_line_required_word_list.append(
                            one_d_each_line_each_word_list_stripped[6].replace(type_size[0] + ":", " "))

                    except Exception as e:
                        logging.exception(e)
                else:
                    sheet1.write(flag, 1, list_1d_arrays[k])
                    k += 1
                for j in range(len(one_d_each_line_required_word_list)):
                    sheet1.write(flag, j + 1, one_d_each_line_required_word_list[j])
                sheet1.write(flag, 0, flag)
                flag += 1

            flag1 = flag
            two_d_each_line_list = full_file_3_test_list[1].split("\n")
            two_d_each_line_list.remove('')
            sheet1.write(flag1 + 1, 1, two_d_each_line_list[0])
            for ele in range(len(two_d_each_line_list[1:])):
                two_d_each_line_each_word_list_stripped = []
                two_d_each_line_required_word_list = []
                if two_d_each_line_list[1:][ele].startswith(" hip"):
                    two_d_each_line_each_word_list = two_d_each_line_list[1:][ele].split(" ")
                    for ele in two_d_each_line_each_word_list:
                        if ele.strip():
                            two_d_each_line_each_word_list_stripped.append(ele.strip())
                    two_d_each_line_required_word_list.append(two_d_each_line_each_word_list_stripped[0] + " " +
                                                              two_d_each_line_each_word_list_stripped[1])

                    two_d_each_line_required_word_list.append(two_d_each_line_each_word_list_stripped[3] +
                                                              two_d_each_line_each_word_list_stripped[4] +
                                                              two_d_each_line_each_word_list_stripped[5] + " " +
                                                              two_d_each_line_each_word_list_stripped[6])

                    two_d_each_line_required_word_list.append("NA")

                    name2 = two_d_each_line_each_word_list_stripped[-1]
                    two_d_each_line_required_word_list.append(name2)
                for m in range(len(two_d_each_line_required_word_list)):
                    try:
                        sheet1.write(flag1 + 2, m + 1, two_d_each_line_required_word_list[m])

                    except Exception as e:
                        sheet1.write(flag, 1, list_2d_arrays[l])
                        l += 1
                sheet1.write(flag1, 0, flag1)
                flag1 += 1
            flag2 = flag1

            three_d_each_line_list = full_file_3_test_list[2].split("\n")
            three_d_each_line_list.remove('')
            sheet1.write(flag2 + 3, 1, three_d_each_line_list[0])

            for ele in range(len(three_d_each_line_list[1:])):
                three_d_each_line_each_word_list_stripped = []
                three_d_each_line_required_word_list = []
                if three_d_each_line_list[1:][ele].startswith(" hip"):
                    three_d_each_line_each_word_list = three_d_each_line_list[1:][ele].split(" ")
                    for ele in three_d_each_line_each_word_list:
                        if ele.strip():
                            three_d_each_line_each_word_list_stripped.append(ele.strip())
                    three_d_each_line_required_word_list.append(three_d_each_line_each_word_list_stripped[0] +
                                                                " " +
                                                                three_d_each_line_each_word_list_stripped[1])

                    three_d_each_line_required_word_list.append(three_d_each_line_each_word_list_stripped[3] +
                                                                three_d_each_line_each_word_list_stripped[4] +
                                                                three_d_each_line_each_word_list_stripped[5] +
                                                                three_d_each_line_each_word_list_stripped[6] +
                                                                three_d_each_line_each_word_list_stripped[
                                                                    7] + " " +
                                                                three_d_each_line_each_word_list_stripped[8])

                    three_d_each_line_required_word_list.append("NA")

                    name2 = three_d_each_line_each_word_list_stripped[-1]
                    three_d_each_line_required_word_list.append(name2)
                sno_3d = flag2
                for m in range(len(three_d_each_line_required_word_list)):
                    try:
                        sheet1.write(flag2 + 4, m + 1, three_d_each_line_required_word_list[m])
                        sheet1.write(sno_3d, 0, sno_3d)
                        sno_3d += 1

                    except Exception as e:
                        sheet1.write(flag, 1, list_3d_arrays[l])
                        l += 1
                        sheet1.write(sno_3d, 0, sno_3d)
                        sno_3d += 1
                flag2 += 1
                sheet1.write(sno_3d, 0, sno_3d)
                sno_3d += 1
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipPerfMemSet")


class HipRT_Parser:
    """
    Class contains api for all hipRT benchmark logs to convert to excel scores
    """

    @staticmethod
    def hiprt_log_parser(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipperf buffercoptrectspeed and buffercopyspeed benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
            sheet1 = book.add_worksheet()

            column = 1
            with open(txt_path, "r") as f_in:
                full_file_each_test = f_in.read().split("[ RUN      ]")

            time_unit = []
            for i in range(len(full_file_each_test[1:])):
                each_test_each_line_list = full_file_each_test[1:][i].split("\n")
                sheet1.write(i + 1, column - 1, i + 1)  # serial number
                sheet1.write(i + 1, column, each_test_each_line_list[0])
                shared_memory = re.findall(".*shared memory(.*)", full_file_each_test[1:][i])
                kernal_time = re.findall("Trace kernel: registers(.*),", full_file_each_test[1:][i])
                build_time = re.findall("Bvh Build Time :(.*)", full_file_each_test[1:][i])
                ray_cast_time = re.findall("Ray Cast Time:(.*)", full_file_each_test[1:][i])

                data_list = [shared_memory, kernal_time, build_time, ray_cast_time]
                for k in range(len(data_list)):
                    if len(data_list[k]) != 0:
                        if data_list[k][0].strip().isnumeric():
                            sheet1.write(i + 1, k + 2, data_list[k][0])
                        else:
                            ray_cast_total_time_unit_list = re.split("\d+\s(\w+)", data_list[k][0])
                            if ray_cast_total_time_unit_list[1] not in time_unit:
                                time_unit.append(ray_cast_total_time_unit_list[1])
                            value = data_list[k][0].replace(ray_cast_total_time_unit_list[1], '')
                            sheet1.write(i + 1, k + 2, value)
                for j in each_test_each_line_list:
                    if j.startswith("[       OK ]"):
                        total_memory = re.sub(r"\D", "", j)
                        sheet1.write(i + 1, 6, total_memory)
            sheet1.write(0, 0, "S.no")
            sheet1.write(0, 1, "Testname")
            sheet1.write(0, 2, "shared_memory")
            sheet1.write(0, 3, "kernel_registers")
            sheet1.write(0, 4, f"Bvh Build Time ({time_unit[0]})")
            sheet1.write(0, 5, f"Ray Cast Time ({time_unit[0]})")
            sheet1.write(0, 6, f"total time ({time_unit[0]})")
            book.close()
        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipRT")


class HipCub_RocPrim_Parser:
    """
    Class contains api for all hipcub benchmark logs to convert to excel scores
    """

    @staticmethod
    def hipcub_rocprim_log_parser(log_path_list, txt_path, filename):
        """
         This api will generate excel file for hipcub benchmark
         :param filename: text filename
         :param log_path_list: Path of text files
         :param txt_path: txt file full location
         """
        try:
            sorted_size = []
            if filename != "rp_config_dispatch.txt":
                current_txt_file = open(txt_path, 'r', encoding='utf-8')

                book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
                sheet1 = book.add_worksheet()
                current_line_cnt = 0
                row_cnt = 1
                for current_line_in_current_txt_file in current_txt_file:
                    each_line_each_item_list = []

                    if current_line_cnt > 2:
                        if filename == 'rp_block_sort.txt':
                            match_obj = re.search(
                                r"(.*)\s+(\d+\.?\d+ ms)\s+(\d+\.?\d+ ms)\s+(\d+)\s+(bytes_.*)\s+(items_.*)\s(sorted_.*)$",
                                current_line_in_current_txt_file)
                            if match_obj:
                                sorted_size.append(match_obj.group(7))
                        else:
                            match_obj = re.search(
                                r"(.*)\s+(\d+\.?\d+ ms)\s+(\d+\.?\d+ ms)\s+(\d+)\s+(bytes_.*)\s+(items_.*)$",
                                current_line_in_current_txt_file)
                        if match_obj:
                            each_line_each_item_list = [
                                match_obj.group(1),
                                match_obj.group(2),
                                match_obj.group(3),
                                match_obj.group(4),
                                match_obj.group(5),
                                match_obj.group(6)
                            ]

                            time_value_list = re.split("\d+\s+(\w+)", each_line_each_item_list[1])
                            cpu_value_list = re.split("\d+\s+(\w+)", each_line_each_item_list[2])
                            counter_bytes_per_sec = re.split("(\w+=)\d+", each_line_each_item_list[4])
                            counter_items_per_sec = re.split("(\w+=)\d+", each_line_each_item_list[5])
                            time_value = each_line_each_item_list[1].replace(time_value_list[1], "")
                            cpu_value = each_line_each_item_list[2].replace(cpu_value_list[1], "")
                            counter_bytes_per_sec_value = each_line_each_item_list[4].replace(counter_bytes_per_sec[1],
                                                                                              " ")
                            counter_items_per_sec_value = each_line_each_item_list[5].replace(counter_items_per_sec[1],
                                                                                              " ")
                            bytes_per_sec_unit_list = re.split("\d+(\w+/\w+)", counter_bytes_per_sec_value)
                            items_per_sec_unit_list = re.split("\d+(\w+/\w+)", counter_items_per_sec_value)

                            flag_each_line_each_item_list_len = 0
                            while flag_each_line_each_item_list_len < len(each_line_each_item_list):
                                if flag_each_line_each_item_list_len == 1:
                                    sheet1.write(row_cnt, flag_each_line_each_item_list_len, time_value)
                                elif flag_each_line_each_item_list_len == 2:
                                    sheet1.write(row_cnt, flag_each_line_each_item_list_len, cpu_value)
                                elif flag_each_line_each_item_list_len == 4:
                                    if bytes_per_sec_unit_list[1] == "T/s":
                                        x = counter_bytes_per_sec_value.replace("T/s", "")
                                        result = float(x) * 1024
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, result)
                                    elif bytes_per_sec_unit_list[1] == "P/s":
                                        y = counter_bytes_per_sec_value.replace("P/s", "")
                                        result_y = float(y) * 1048576
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, result_y)
                                    elif bytes_per_sec_unit_list[1] == "M/s":
                                        z = counter_bytes_per_sec_value.replace("M/s", "")
                                        result_z = float(z) * 1048576
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, result_z)
                                    elif bytes_per_sec_unit_list[1] == "G/s":
                                        value = counter_bytes_per_sec_value.replace("G/s", "")
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, value)
                                elif flag_each_line_each_item_list_len == 5:
                                    if items_per_sec_unit_list[1] == "T/s":
                                        l = counter_items_per_sec_value.replace("T/s", "")
                                        result_l = float(l) * 1024
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, result_l)
                                    elif items_per_sec_unit_list[1] == "P/s":
                                        p = counter_items_per_sec_value.replace("P/s", "")
                                        result_p = float(p) * 1048576
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, result_p)
                                    elif items_per_sec_unit_list[1] == "M/s":
                                        m = counter_items_per_sec_value.replace("M/s", "")
                                        result_m = float(m) * 0.0001
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, result_m)
                                    elif items_per_sec_unit_list[1] == "G/s":
                                        value = counter_items_per_sec_value.replace("G/s", "")
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len, value)
                                else:
                                    if each_line_each_item_list[flag_each_line_each_item_list_len].startswith('"Sp'):
                                        if "warp_reduce" in each_line_each_item_list[flag_each_line_each_item_list_len]:
                                            match_obj = re.findall(r"(.*)warp_reduce<Datatype:.*",
                                                                   each_line_each_item_list[
                                                                       flag_each_line_each_item_list_len])
                                            if len(match_obj) >= 1:
                                                data = each_line_each_item_list[
                                                    flag_each_line_each_item_list_len].replace(match_obj[0], " ")
                                                sheet1.write(row_cnt, flag_each_line_each_item_list_len, data)
                                        elif "warp_scan" in each_line_each_item_list[flag_each_line_each_item_list_len]:
                                            match_obj1 = re.findall(r"(.*)warp_scan<Datatype:.*",
                                                                    each_line_each_item_list[
                                                                        flag_each_line_each_item_list_len])
                                            if len(match_obj1) >= 1:
                                                data1 = each_line_each_item_list[
                                                    flag_each_line_each_item_list_len].replace(match_obj1[0], " ")
                                                sheet1.write(row_cnt, flag_each_line_each_item_list_len, data1)
                                    else:
                                        sheet1.write(row_cnt, flag_each_line_each_item_list_len,
                                                     each_line_each_item_list[flag_each_line_each_item_list_len])
                                flag_each_line_each_item_list_len += 1
                            row_cnt += 1
                    current_line_cnt += 1
                sheet1.write(0, 0, "Benchmark ")
                sheet1.write(0, 1, f"Time (ms)")
                sheet1.write(0, 2, f"CPU (ms))")
                sheet1.write(0, 3, f"Iterations ")
                sheet1.write(0, 4, f"Bytes_per_sec (G/s)")
                sheet1.write(0, 5, f"Items_per_sec (G/s)")
                book.close()

                if filename == 'rp_block_sort.txt':
                    block_sort_workbook = load_workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
                    ws = block_sort_workbook.active
                    ws.insert_cols(2, 1)
                    ws.cell(row=1, column=2).value = "Sorted_Size"
                    row_count_sorted_size = 2
                    for i in sorted_size:
                        ws.cell(row=row_count_sorted_size, column=2).value = i
                        row_count_sorted_size += 1
                    block_sort_workbook.save(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")

            else:
                try:
                    config_values = []
                    current_txt_file = open(txt_path, 'r', encoding='utf-8')

                    book = xlsxwriter.Workbook(f"{log_path_list[0]}/{filename.replace('.txt', '')}.xlsx")
                    sheet1 = book.add_worksheet()

                    current_line_cnt = 0
                    row_cnt = 1

                    for current_line_in_current_txt_file in current_txt_file:
                        content = []
                        if current_line_cnt > 2:
                            match_obj = re.search(r"(.*)\s+(\d+\.?\d+ ns)\s+(\d+\.?\d+ ns)\s+(\d+)$",
                                                  current_line_in_current_txt_file)
                            if match_obj:
                                content = [
                                    match_obj.group(1),
                                    match_obj.group(2),
                                    match_obj.group(3),
                                    match_obj.group(4),
                                ]
                                time = re.split("\d+\.?\d+\s+(\w+)", content[1])
                                cpu = re.split("\d+\s+(\w+)", content[2])
                                time_value = content[1].replace(time[1], "")
                                config_values.append(content[0])

                                cpu_value = content[2].replace(cpu[1], "")
                                config_values.append(content[3])
                                config_values.append(cpu_value)
                                config_values.append(time_value)

                        current_line_cnt += 1
                    flag = 1
                    flag1 = 0
                    for value in range(len(config_values)):
                        sheet1.write(flag, flag1, config_values[value])
                        flag1 += 1
                        if flag1 == 4:
                            flag += 1
                            flag1 = 0
                    sheet1.write(0, 0, "Benchmark ")
                    sheet1.write(0, 1, f"Iterations ")
                    sheet1.write(0, 2, f"CPU")
                    sheet1.write(0, 3, f"Time (ns)")
                    book.close()
                except Exception as e:
                    logging.error("Issue with Config Dispatch")
                    logging.exception(e)

        except Exception as e:
            logging.exception(e)
            logging.error("Issue observed in creating excel file for hipCub")


def reports_last_log_folder():
    """
    This api will return last folder in Reports folder
    :return: Absolute path of last folder in Reports folder
    """
    try:
        path = os.path.abspath(os.path.join('..\..\Reports'))
        logging.debug(f"this is path {path} ")
        last_log_folder = os.listdir(r"..\..\Reports")[-1]
        logging.debug(f" This is last_log_folder {last_log_folder}")
        last_log_folder_abs_path = path + '\\' + last_log_folder
        logging.debug(f" this is last_log_folder_abs_path {last_log_folder_abs_path}")
        return last_log_folder_abs_path
    except Exception as e:
        logging.error("Failed to return reports Last logs folder - reports_last_log_folder()")
        logging.exception(e)


def benchmark_run_summary_report():
    """
    This api generate the benchmark Summary report for the last run
    """
    try:
        time.sleep(5)  # Sleep time required to generate all excel files in the logs folder
        log_path = reports_last_log_folder()

        dir_containing_files = log_path.replace("\\", "\\\\")
        dest_wb = Workbook()
        for root, dir, filenames in os.walk(dir_containing_files):
            for file in filenames:
                if file.endswith(".xlsx"):
                    file_name = file.split('.')[0]
                    file_path = os.path.abspath(os.path.join(root, file))
                    dest_wb.create_sheet(file_name)
                    dest_ws = dest_wb[file_name]
                    source_wb = load_workbook(file_path)
                    source_sheet = source_wb.active
                    for i in source_sheet.rows:
                        for cell in i:
                            dest_ws[cell.coordinate] = cell.value
            dest_wb.save(rf"{log_path}\Benchmark_Summary_report.xlsx")

        time.sleep(10)  # Sleep time required to write all sheets in summary report
        file_workbook = rf"{log_path}\Benchmark_Summary_report.xlsx"
        wb = load_workbook(file_workbook)
        if 'Sheet1' in wb.sheetnames:
            wb.remove(wb['Sheet1'])
        if 'Sheet' in wb.sheetnames:
            wb.remove(wb['Sheet'])
        wb.save(file_workbook)
        return True
    except Exception as e:
        logging.error("Failed to generate benchmark summary report")
        logging.exception(e)
        return False


def list_common_sheets(arr1, arr2, arr3):
    """
    This api will check the common excel sheets in benchmark summary reports
    :param arr1: benchmark summary report 1 list
    :param arr2: benchmark summary report 2 list
    :param arr3: benchmark summary report 3 list
    :return: common excel sheets list
    """
    try:
        report_1_set = set(arr1)
        report_2_set = set(arr2)
        report_3_set = set(arr3)
        set1 = report_1_set.intersection(report_2_set)  # [80, 20, 100]
        result_set = set1.intersection(report_3_set)
        common_sheets_list = list(result_set)
        logging.debug(f"Common sheets present in all 46 runs : \n{common_sheets_list}")
        logging.debug(f"Expected count for mathlibs : 46 , actual count {len(common_sheets_list)}")
        return common_sheets_list
    except Exception as e:
        logging.exception(e)


def list_difference_sheets(arr1, arr2, arr3):
    """
    This api will check the missing excel sheets in benchmark summary reports
    :param arr1: benchmark summary report 1 list
    :param arr2: benchmark summary report 2 list
    :param arr3: benchmark summary report 3 list
    :return: missing excel sheets list
    """
    try:
        report_1_set = set(arr1)
        report_2_set = set(arr2)
        report_3_set = set(arr3)
        diff1 = report_1_set.difference(report_2_set)
        result_diff = diff1.difference(report_3_set)
        missing_sheets_list = list(result_diff)
        if len(missing_sheets_list) > 0:
            logging.debug(f"These {len(missing_sheets_list)}sheets are missing/ not common in all 3 summary reports:"
                          f" \n{missing_sheets_list}")
        else:
            logging.debug(f"Both have same common sheets: {missing_sheets_list}")
        return missing_sheets_list
    except Exception as e:
        logging.exception(e)


def benchmark_three_runs_report():
    """
    This api will generate a new excel files having scores of last 3 runs in single excel file for best score compare
    """
    list_ele1 = []
    list_ele2 = []
    list_ele3 = []
    error_flag = 0
    benchmark_summary_report_1 = ''
    benchmark_summary_report_2 = ''
    benchmark_summary_report_3 = ''

    # path = r"E:\GAURAV_SONI_WORK\Benchmarks\parser_learn"
    path = os.path.abspath(os.path.join('..\..\Reports'))
    last_log_folder = os.listdir(path)[-2]
    secondlast_log_folder = os.listdir(path)[-3]
    thirdlast_log_folder = os.listdir(path)[-4]

    last_log_folder_abs_path = path + '\\' + last_log_folder
    # logging.debug(f"This is last_log_folder_abs_path {last_log_folder_abs_path}")
    secondlast_log_folder_abs_path = path + '\\' + secondlast_log_folder
    thirdlast_log_folder_abs_path = path + '\\' + thirdlast_log_folder

    def summary_report_abs_path(log_path):
        """
        This api check if benchmark summary report folder present in the given logs path ,
        and will return the name of the file
        :param log_path:
        :return:
        """
        try:
            dir_containing_files = log_path.replace("\\", "\\\\")
            for root, dir, filenames in os.walk(dir_containing_files):
                for file in filenames:
                    if file.startswith("Benchmark_Summary_"):
                        if file.endswith(".xlsx"):
                            return file
        except Exception as e:
            logging.exception(e)

    log_path = last_log_folder_abs_path
    # benchmark_summary_report_3 = last_log_folder_abs_path + "\\" + summary_report_abs_path(log_path)
    benchmark_summary_report_3 = f"{last_log_folder_abs_path}\\{summary_report_abs_path(log_path)}"

    log_path = secondlast_log_folder_abs_path
    benchmark_summary_report_2 = f"{secondlast_log_folder_abs_path}\\{summary_report_abs_path(log_path)}"

    log_path = thirdlast_log_folder_abs_path
    benchmark_summary_report_1 = f"{thirdlast_log_folder_abs_path}\\{summary_report_abs_path(log_path)}"

    logging.debug(f"Path of benchmark_summary_report_1 : {benchmark_summary_report_1}")
    logging.debug(f"Path of benchmark_summary_report_2 : {benchmark_summary_report_2}")
    logging.debug(f"Path of benchmark_summary_report_3 : {benchmark_summary_report_3}\n\n")

    benchmark_summary_report_1.replace("\\", "\\\\")
    benchmark_summary_report_2.replace("\\", "\\\\")
    benchmark_summary_report_3.replace("\\", "\\\\")

    workbook_1 = load_workbook(rf"{benchmark_summary_report_1}")
    workbook_2 = load_workbook(rf"{benchmark_summary_report_2}")
    workbook_3 = load_workbook(rf"{benchmark_summary_report_3}")

    for i in workbook_1.sheetnames:
        if i != "Sheet":
            list_ele1.append(i)
    # logging.debug(list_ele1)
    for i in workbook_2.sheetnames:
        if i != "Sheet":
            list_ele2.append(i)
    for i in workbook_3.sheetnames:
        if i != "Sheet":
            list_ele3.append(i)

    if len(list_difference_sheets(list_ele1, list_ele2, list_ele3)) > 0:
        error_flag = 1

    for i in list_common_sheets(list_ele1, list_ele2, list_ele3):
        labels = []
        sheet1 = workbook_1[i]
        sheet2 = workbook_2[i]
        sheet3 = workbook_3[i]
        for header_row in sheet1[1]:
            labels.append(header_row)
        count = labels.index(labels[-1])
        for dest_row, orig_col_c in enumerate(sheet1[labels[-1].column_letter], 1):
            sheet3.cell(row=dest_row, column=count + 2).value = orig_col_c.value
        for dest_row, orig_col_c in enumerate(sheet2[labels[-1].column_letter], 1):
            sheet3.cell(row=dest_row, column=count + 3).value = orig_col_c.value
    workbook_3.save(rf"{reports_last_log_folder()}\3_Runs_Report_{timestamp}.xlsx")
    time.sleep(3)
    logging.debug(f"Three runs report has been generated Successfully path : {path}\\3_Runs_Report_{timestamp}.xlsx")

    if error_flag == 1:
        logging.error("SOME ISSUE OBSERVED DURING CREATION OF THREE RUNS REPORT FOR FEW OF THE SHEETS. "
                      "CHECK AUTOMATION LOGS FOR MORE INFO")


def benchmark_best_score_report():
    """
    This api will create a best score report for the latest 3 runs report created
    """
    # path = os.path.abspath(os.path.join('..\..\Reports'))
    path = reports_last_log_folder()
    time.sleep(5)
    workbook_4 = load_workbook(rf"{path}\3_Runs_Report_{timestamp}.xlsx")
    all_sheets_list = []
    for i in workbook_4.sheetnames:
        if i != "Sheet":
            all_sheets_list.append(i)
    logging.debug(f"All sheets considered for best run comparison :\n{all_sheets_list}")
    for i in range(len(all_sheets_list)):
        header_row = []
        workbook_4.active = i
        active_sheet = workbook_4.active

        for x in active_sheet[1]:
            header_row.append(x)
        header_row_column_count = header_row.index(header_row[-1])

        abc_header_last_column = openpyxl.utils.cell.get_column_letter(header_row_column_count + 1)
        abc_header_secondlast_column = openpyxl.utils.cell.get_column_letter(header_row_column_count)
        abc_header_thirdlast_column = openpyxl.utils.cell.get_column_letter(header_row_column_count - 1)
        abc_header_best_score_column = openpyxl.utils.cell.get_column_letter(header_row_column_count + 2)

        active_sheet[abc_header_best_score_column + "1"] = "Best Score"

        last_column = active_sheet[abc_header_last_column]
        second_last_column = active_sheet[abc_header_secondlast_column]
        third_last_column = active_sheet[abc_header_thirdlast_column]

        column_length = 0
        if len(last_column) <= len(second_last_column) and len(last_column) <= len(third_last_column):
            column_length = len(last_column)
        if len(second_last_column) <= len(last_column) and len(second_last_column) <= len(third_last_column):
            column_length = len(last_column)
        if len(third_last_column) <= len(last_column) and len(third_last_column) <= len(second_last_column):
            column_length = len(last_column)

        last_column_given_heading_cell = active_sheet[abc_header_last_column + str(1)]

        for i in range(2, column_length + 1):
            last_column_cell = active_sheet[abc_header_last_column + str(i)]
            secondlast_column_cell = active_sheet[abc_header_secondlast_column + str(i)]
            thirdlast_column_cell = active_sheet[abc_header_thirdlast_column + str(i)]
            if "GB/S" in last_column_given_heading_cell.value or \
                    "Gflops/s" in last_column_given_heading_cell.value or \
                    "GB/s" in last_column_given_heading_cell.value or \
                    "Gflops" in last_column_given_heading_cell.value or \
                    "gB/S" in last_column_given_heading_cell.value or \
                    "G/s" in last_column_given_heading_cell.value:
                # if "GB/S" or "Gflops/s" or "GB/s" or "gB/S" in column_name.value:
                try:
                    active_sheet[abc_header_best_score_column + str(i)] = (float(last_column_cell.value) +
                                                                           float(secondlast_column_cell.value) +
                                                                           float(thirdlast_column_cell.value))/3
                except Exception as e:
                    value = " "
                    active_sheet[abc_header_best_score_column + str(i)] = value
            else:
                try:
                    active_sheet[abc_header_best_score_column + str(i)] = (float(last_column_cell.value) +
                                                                           float(secondlast_column_cell.value) +
                                                                           float(thirdlast_column_cell.value))/3
                except Exception as e:
                    value = " "
                    active_sheet[abc_header_best_score_column + str(i)] = value
    workbook_4.save(rf"{path}\Best_Score_Report_{timestamp}.xlsx")
    time.sleep(5)
    logging.debug("Best run Score for the last three run generated successfully!!")
    logging.debug(f"Best Run Report path : {path}\Best_Score_Report_{timestamp}.xlsx")


def windows_vs_linux_comparison_report(compare_param):
    """
    This api will generate the final comparison report for the old run and new run / windows score vs linux score
    :param compare_param: benchmark test to be compared ( mathlib/hipperf/rocprim/hipcub )
    """
    try:
        list_ele1 = []
        list_ele2 = []
        error_flag = 0
        # path = os.path.abspath(os.path.join('..\..\Reports'))
        path = reports_last_log_folder()
        new_best_run_report = fr"{path}\Best_Score_Report_{timestamp}.xlsx"

        golden_report_file_name = ''
        golden_report_path = ''
        if compare_param == 'mathlib':
            golden_report_path = os.path.abspath(os.path.join(r'..\..\Tools\benchmark_mathlib'))
        elif compare_param == 'hipperf':
            golden_report_path = os.path.abspath(os.path.join(r'..\..\Tools\benchmark_hipperf'))
        elif compare_param == 'hipcub':
            golden_report_path = os.path.abspath(os.path.join(r'..\..\Tools\benchmark_hipcub'))
        elif compare_param == 'rocprim':
            golden_report_path = os.path.abspath(os.path.join(r'..\..\Tools\benchmark_rocprim'))
        elif compare_param == 'hiprt':
            golden_report_path = os.path.abspath(os.path.join(r'..\..\Tools\benchmark_hiprt'))

        try:
            dir_containing_files = golden_report_path.replace("\\", "\\\\")
            for root, dir, filenames in os.walk(dir_containing_files):
                for file in filenames:
                    if file.endswith(".xlsx"):
                        golden_report_file_name = file
        except Exception as e:
            logging.exception(e)

        old_golden_best_run_report = fr"{golden_report_path}\{golden_report_file_name}"

        new_best_run_report.replace("\\", "\\\\")
        old_golden_best_run_report.replace("\\", "\\\\")

        workbook_new = load_workbook(rf"{new_best_run_report}")
        workbook_old = load_workbook(rf"{old_golden_best_run_report}")

        for i in workbook_old.sheetnames:
            if i != "Sheet":
                list_ele1.append(i)
        for i in workbook_new.sheetnames:
            if i != "Sheet":
                list_ele2.append(i)

        difference_sheets_list = list_difference_sheets(list_ele1, list_ele2, list_ele2)

        if len(difference_sheets_list) > 0:
            error_flag = 1

        common_sheets_list = list_common_sheets(list_ele1, list_ele2, list_ele2)
        for i in common_sheets_list:
            labels = []
            new_run_sheet = workbook_new[i]
            old_run_sheet = workbook_old[i]

            for header_row in old_run_sheet[1]:
                labels.append(header_row)

            count = labels.index(labels[-1])
            for dest_row, orig_col_c in enumerate(new_run_sheet[labels[-1].column_letter], 1):
                old_run_sheet.cell(row=dest_row, column=count + 5).value = orig_col_c.value
            for dest_row, orig_col_c in enumerate(new_run_sheet[labels[-2].column_letter], 1):
                old_run_sheet.cell(row=dest_row, column=count + 4).value = orig_col_c.value
            for dest_row, orig_col_c in enumerate(new_run_sheet[labels[-3].column_letter], 1):
                old_run_sheet.cell(row=dest_row, column=count + 3).value = orig_col_c.value
            for dest_row, orig_col_c in enumerate(new_run_sheet[labels[-4].column_letter], 1):
                old_run_sheet.cell(row=dest_row, column=count + 2).value = orig_col_c.value

        workbook_old.save(rf"{path}\FINAL_COMPARISON_REPORT_{timestamp}.xlsx")

        workbook_comparison = load_workbook(rf"{path}\FINAL_COMPARISON_REPORT_{timestamp}.xlsx")

        time.sleep(3)
        comparison_report_sheet_list = []
        drop_count_list = []
        issue_sheets = []

        for i in difference_sheets_list:
            del workbook_comparison[i]

        for i in workbook_comparison.sheetnames:
            if i != "Sheet":
                comparison_report_sheet_list.append(i)

        for i in range(len(comparison_report_sheet_list)):
            header_row = []
            workbook_comparison.active = i
            active_sheet = workbook_comparison.active
            drop_count = 0

            for x in active_sheet[1]:
                header_row.append(x)
            header_row_column_count = header_row.index(header_row[-1])

            abc_header_new_run_best_column = openpyxl.utils.cell.get_column_letter(header_row_column_count + 1)
            abc_header_old_run_best_column = openpyxl.utils.cell.get_column_letter(header_row_column_count - 3)
            abc_header_old_run_3rd_run_column = openpyxl.utils.cell.get_column_letter(header_row_column_count - 4)
            abc_header_diff_column = openpyxl.utils.cell.get_column_letter(header_row_column_count + 2)

            active_sheet[abc_header_old_run_best_column + "1"] = "OLD Best Score"
            active_sheet[abc_header_old_run_best_column + "1"].font = Font(bold=True)
            active_sheet[abc_header_old_run_best_column + str(1)].fill = PatternFill(start_color="00FFFF00",
                                                                                     end_color="00FFFF00",
                                                                                     fill_type="solid")
            active_sheet[abc_header_new_run_best_column + "1"] = "NEW Best Score"
            active_sheet[abc_header_new_run_best_column + "1"].font = Font(bold=True)
            active_sheet[abc_header_new_run_best_column + str(1)].fill = PatternFill(start_color="00FFFF00",
                                                                                     end_color="00FFFF00",
                                                                                     fill_type="solid")
            active_sheet[abc_header_diff_column + "1"] = "DIFF"
            active_sheet[abc_header_diff_column + "1"].font = Font(bold=True)
            active_sheet[abc_header_diff_column + str(1)].fill = PatternFill(start_color="00FFCC99",
                                                                             end_color="00FFCC99",
                                                                             fill_type="solid")
            new_run_best_column = active_sheet[abc_header_new_run_best_column]
            old_run_best_column = active_sheet[abc_header_old_run_best_column]

            column_length = 0
            if len(new_run_best_column) <= len(old_run_best_column):
                column_length = len(new_run_best_column)
            else:
                column_length = len(old_run_best_column)

            old_run_3rd_run_column_given_heading_cell = active_sheet[abc_header_old_run_3rd_run_column + str(1)]

            for i in range(2, column_length + 1):
                new_run_best_column_cell = active_sheet[abc_header_new_run_best_column + str(i)]
                old_run_best_column_cell = active_sheet[abc_header_old_run_best_column + str(i)]
                new_run_best_column_cell.fill = PatternFill(start_color="00FFFF00", end_color="00FFFF00",
                                                            fill_type="solid")
                new_run_best_column_cell.font = Font(bold=True)
                old_run_best_column_cell.fill = PatternFill(start_color="00FFFF00", end_color="00FFFF00",
                                                            fill_type="solid")
                old_run_best_column_cell.font = Font(bold=True)

                if "GB/S" in old_run_3rd_run_column_given_heading_cell.value or \
                        "Gflops/s" in old_run_3rd_run_column_given_heading_cell.value or \
                        "GB/s" in old_run_3rd_run_column_given_heading_cell.value or \
                        "Gflops" in old_run_3rd_run_column_given_heading_cell.value or \
                        "gB/S" in old_run_3rd_run_column_given_heading_cell.value or \
                        "G/S" in old_run_3rd_run_column_given_heading_cell.value or \
                        "G/s" in old_run_3rd_run_column_given_heading_cell.value:
                    try:
                        diff = float(new_run_best_column_cell.value) - float(old_run_best_column_cell.value)
                        decimal = diff / float(old_run_best_column_cell.value)
                        active_sheet[abc_header_diff_column + str(i)] = decimal
                        active_sheet[abc_header_diff_column + str(i)].number_format = FORMAT_PERCENTAGE
                        active_sheet[abc_header_diff_column + str(i)].number_format = '#,##0.000%'
                        active_sheet[abc_header_diff_column + str(i)].font = Font(bold=True)
                    except Exception as e:
                        value = "No Score Available "
                        active_sheet[abc_header_diff_column + str(i)] = value
                else:
                    try:
                        diff = float(old_run_best_column_cell.value) - float(new_run_best_column_cell.value)
                        decimal = diff / float(old_run_best_column_cell.value)
                        active_sheet[abc_header_diff_column + str(i)] = decimal
                        active_sheet[abc_header_diff_column + str(i)].number_format = FORMAT_PERCENTAGE
                        active_sheet[abc_header_diff_column + str(i)].number_format = '#,##0.000%'
                        active_sheet[abc_header_diff_column + str(i)].font = Font(bold=True)

                    except Exception as e:
                        value = "No Score Available "
                        active_sheet[abc_header_diff_column + str(i)] = value

                current_cell = active_sheet[abc_header_diff_column + str(i)]
                if type(current_cell.value) == float and current_cell.value < -0.05:
                    current_cell.fill = PatternFill(start_color="00FF0000", end_color="00FF0000", fill_type='lightDown')
                    if active_sheet not in issue_sheets:
                        issue_sheets.append(active_sheet)
                        active_sheet.sheet_properties.tabColor = 'FF0000'
                    logging.warning(f"{active_sheet} has drop observed of : {current_cell.value * 100:.2f} %")
                    drop_count += 1
                elif type(current_cell.value) == float and current_cell.value > -0.05:
                    current_cell.fill = PatternFill(start_color="0099CC00", end_color="0099CC00", fill_type='lightDown')
            if drop_count > 0:
                drop_count_list.append(drop_count)

        time.sleep(5)
        workbook_windows_all_sheets_list = []
        for i in workbook_new.sheetnames:
            if i != "Sheet":
                workbook_windows_all_sheets_list.append(i)

        # for i in difference_sheets_list:
        #     del workbook_comparison[i]
        time.sleep(2)
        workbook_comparison.save(rf"{path}\FINAL_COMPARISON_REPORT_{timestamp}.xlsx")
        logging.debug(
            f"Comparison report has been generated Successfully path : \n"
            f"{path}\\FINAL_COMPARISON_REPORT_{timestamp}.xlsx\n")

        logging.warning(f"THESE ARE THE ISSUE SHEETS:")
        for ct, dc in zip(issue_sheets, drop_count_list):
            logging.warning(f"{ct}     Number of tests having drops more than 5% are : {dc}")
        logging.warning(f"TOTAL NUMBER OF SHEETS HAVING ISSUE : {len(issue_sheets)}")

        if error_flag == 1:
            logging.warning(
                "SOME ISSUE OBSERVED DURING CREATION OF THREE RUNS REPORT FROM FEW OF THE SHEETS. CHECK AUTOMATION LOGS")
    except Exception as e:
        logging.error("Failed to generate the final comparison report")
        logging.exception(e)
